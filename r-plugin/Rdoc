Normal                         package:stats                         R Documentation

_T_h_e _N_o_r_m_a_l _D_i_s_t_r_i_b_u_t_i_o_n

_D_e_s_c_r_i_p_t_i_o_n:

     Density, distribution function, quantile function and random generation for the
     normal distribution with mean equal to ‘mean’ and standard deviation equal
     to ‘sd’.

_U_s_a_g_e:

     dnorm(x, mean = 0, sd = 1, log = FALSE)
     pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)
     qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)
     rnorm(n, mean = 0, sd = 1)
     
_A_r_g_u_m_e_n_t_s:

     x,q: vector of quantiles.

       p: vector of probabilities.

       n: number of observations. If ‘length(n) > 1’, the length is taken to be
          the number required.

    mean: vector of means.

      sd: vector of standard deviations.

log, log.p: logical; if TRUE, probabilities p are given as log(p).

lower.tail: logical; if TRUE (default), probabilities are P[X <= x] otherwise, P[X >
          x].

_D_e_t_a_i_l_s:

     If ‘mean’ or ‘sd’ are not specified they assume the default values of
     ‘0’ and ‘1’, respectively.

     The normal distribution has density

                    f(x) = 1/(sqrt(2 pi) sigma) e^-((x - mu)^2/(2 sigma^2))           
     
     where mu is the mean of the distribution and sigma the standard deviation.

     ‘qnorm’ is based on Wichura's algorithm AS 241 which provides precise
     results up to about 16 digits.

_V_a_l_u_e:

     ‘dnorm’ gives the density, ‘pnorm’ gives the distribution function,
     ‘qnorm’ gives the quantile function, and ‘rnorm’ generates random
     deviates.

_S_o_u_r_c_e:

     For ‘pnorm’, based on

     Cody, W. D. (1993) Algorithm 715: SPECFUN - A portable FORTRAN package of
     special function routines and test drivers.  _ACM Transactions on Mathematical
     Software_ *19*, 22-32.

     For ‘qnorm’, the code is a C translation of

     Wichura, M. J. (1988) Algorithm AS 241: The Percentage Points of the Normal
     Distribution.  _Applied Statistics_, *37*, 477-484.

     For ‘rnorm’, see RNG for how to select the algorithm and for references to
     the supplied methods.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S Language_.
     Wadsworth & Brooks/Cole.

     Johnson, N. L., Kotz, S. and Balakrishnan, N. (1995) _Continuous Univariate
     Distributions_, volume 1, chapter 13.  Wiley, New York.

_S_e_e _A_l_s_o:

     ‘runif’ and ‘.Random.seed’ about random number generation, and
     ‘dlnorm’ for the _Log_normal distribution.

_E_x_a_m_p_l_e_s:

     require(graphics)
     
     dnorm(0) == 1/ sqrt(2*pi)
     dnorm(1) == exp(-1/2)/ sqrt(2*pi)
     dnorm(1) == 1/ sqrt(2*pi*exp(1))
     
     ## Using "log = TRUE" for an extended range :
     par(mfrow=c(2,1))
     plot(function(x) dnorm(x, log=TRUE), -60, 50,
          main = "log { Normal density }")
     curve(log(dnorm(x)), add=TRUE, col="red",lwd=2)
     mtext("dnorm(x, log=TRUE)", adj=0)
     mtext("log(dnorm(x))", col="red", adj=1)
     
     plot(function(x) pnorm(x, log.p=TRUE), -50, 10,
          main = "log { Normal Cumulative }")
     curve(log(pnorm(x)), add=TRUE, col="red",lwd=2)
     mtext("pnorm(x, log=TRUE)", adj=0)
     mtext("log(pnorm(x))", col="red", adj=1)
     
     ## if you want the so-called 'error function'
     erf <- function(x) 2 * pnorm(x * sqrt(2)) - 1
     ## (see Abramowitz and Stegun 29.2.29)
     ## and the so-called 'complementary error function'
     erfc <- function(x) 2 * pnorm(x * sqrt(2), lower = FALSE)
     ## and the inverses
     erfinv <- function (x) qnorm((1 + x)/2)/sqrt(2)
     erfcinv <- function (x) qnorm(x/2, lower = FALSE)/sqrt(2)
     
